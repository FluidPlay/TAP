--- unitai_functions => used by unitai_auto_assist and unitai_auto_harvest
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Breno.
--- DateTime: 16-Apr-22 10:24 PM
---

GaiaTeamID = Spring.GetGaiaTeamID()
local defaultOreTowerRange = 330
local spGetFeatureResources = Spring.GetFeatureResources
local spGetUnitHealth   = Spring.GetUnitHealth
local spGetUnitSeparation = Spring.GetUnitSeparation
local spGetFullBuildQueue = Spring.GetFullBuildQueue --use this only for factories, to ignore rally points
local spGetUnitCommands = Spring.GetUnitCommands
local spGetCommandQueue = Spring.GetCommandQueue
local spGetUnitPosition = Spring.GetUnitPosition
local spGetUnitDefID = Spring.GetUnitDefID
local spGetUnitRulesParam = Spring.GetUnitRulesParam
local spValidUnitID = Spring.ValidUnitID
local spGetUnitIsDead = Spring.GetUnitIsDead

---==== Redundant to taptools

function IsValidUnit(unitID)
    if not isnumber(unitID) then
        return false end
    local unitDefID = spGetUnitDefID(unitID)
    if unitDefID and spValidUnitID(unitID) and not spGetUnitIsDead(unitID) then
        return true
    end
    return false
end

----========

local function sqrDistance(x1,z1,x2,z2)
    local dx,dz = x1-x2,z1-z2
    return dx*dx + dz*dz
end

--redundant to taptools, to prevent making this include too big
local function math_clamp(min, max, n)
    if not isnumber(min) or not isnumber(max) or not isnumber(n) then
        return n
    end
    if n > max then
        n = max end
    if n < min then
        n = min end
    return n
end

function HasBuildQueue(unitID)
    if not IsValidUnit(unitID) then
        return end
    local buildqueue = spGetFullBuildQueue(unitID) -- => nil | buildOrders = { [1] = { [number unitDefID] = number count }, ... } }
    --Spring.Echo("build queue size: "..(buildqueue and #buildqueue or "N/A"))
    if buildqueue then
        return #buildqueue > 0
    else
        return false
    end
end

function HasCommandQueue(unitID)
    if not IsValidUnit(unitID) then
        return end
    local commandQueue = spGetCommandQueue(unitID, -1)
    --local unitCommands = spGetUnitCommands(unitID, 20)

    --Spring.Echo("command queue size: "..(#commandQueue or "nil"))

    --if executingCmd[unitID] then
    --    return false
    --end
    if commandQueue then
        return #commandQueue > 0
    end
    return false
end

-- Nearest repairable, including unfinished (under construction, can be assisted)
function getNearestAnyRepairableID (ud)
    --NearestItemAround(unitID, pos, unitDef, radius, defCheck, idCheck, isFeature, teamID, allyTeamID)
    return NearestItemAround(ud.unitID, ud.pos, ud.unitDef, ud.radius,
            function(x) return (x.customParams.isorechunk == nil) end,
            function(x)
                local health,maxHealth,paralyzeDamage,captureProgress,buildProgress=spGetUnitHealth(x)
                --local done = buildProgress and buildProgress >= 1
                if not health or not maxHealth then --or not done then
                    return nil end
                return (health < (maxHealth * 0.99))
            end,
            false,
            ud.team)
end

function getNearestRepairableID (ud)
    return NearestItemAround(ud.unitID, ud.pos, ud.unitDef, ud.radius,
            function(x)
                return (x.customParams == nil or x.customParams.isorechunk == nil) end ,
            function(x)
                local health,maxHealth,_,_,buildProgress = spGetUnitHealth(x)
                local done = buildProgress and buildProgress >= 1
                if health == nil or maxHealth == nil or not done then
                    return nil
                end
                return health < (maxHealth * 0.99) end,
                ud.team
            )
end

function getNearestFeatureID (ud)
    return NearestItemAround(ud.unitID, ud.pos, ud.unitDef, ud.radius, nil, nil, true)
end

function getNearestChunkID (ud)
    return NearestItemAround(ud.unitID, ud.pos, ud.unitDef, ud.harvestRange,
            function(x) return (x.customParams and x.customParams.isorechunk) end, --unitDef check
            nil, false, GaiaTeamID)
end

function getOreTowerCollectRange(parentOreTowerID, oreTowers)
    return oreTowers[parentOreTowerID] or nil
end

function getFarFromOreTower (unitID, oreTowerCollectRange, nearestOreTowerID)
    return oreTowerCollectRange and spGetUnitSeparation(unitID, nearestOreTowerID, false) > oreTowerCollectRange-20 or false
    --TODO: refactor the 'buffer' (20 units now)
end

--function getFarFromOreTower (ud)
--    local otx, oty, otz
--    if ud.parentOreTowerID then
--        otx,oty,otz = spGetUnitPosition(ud.parentOreTowerID)
--    end
--    local farFromOreTower = true
--    if otx and otz then
--        local sqrOreTowerRange = getOreTowerRange(ud.parentOreTowerID)
--        sqrOreTowerRange = sqrOreTowerRange * sqrOreTowerRange
--        farFromOreTower = sqrDistance(ud.pos.x, ud.pos.z, otx, otz) > sqrOreTowerRange
--    end
--end

function getNearestFactoryID (ud)
    --function NearestItemAround(unitID, pos, unitDef, radius, defCheck, idCheck, isFeature, teamID, allyTeamID)
    return NearestItemAround(ud.unitID, ud.pos, ud.unitDef, ud.radius,
            function(x) return x.isFactory end,     -- x.buildOptions and (#(x.buildOptions)>0) --We're only interested in factories currently producing
            function(x) return HasBuildQueue(x) end,
            false,
            ud.team)
end

function getNearestBuilderID (ud)
    return NearestItemAround(ud.unitID, ud.pos, ud.unitDef, ud.radius,
            function(x) return x.isBuilder end,     -- x.buildOptions and (#(x.buildOptions)>0) --We're only interested in factories currently producing
            function(x) return HasBuildQueue(x) end,
            false,
            ud.team)
end

function getNearestMetalID (ud)
    return NearestItemAround(ud.unitID, ud.pos, ud.unitDef, ud.radius, nil,
            function(x)
                local remainingMetal,_,remainingEnergy = spGetFeatureResources(x) --feature
                return remainingMetal and remainingEnergy and remainingMetal > remainingEnergy end,
            true)
end

function getNearestEnergyID(ud)
    return NearestItemAround(ud.unitID, ud.pos, ud.unitDef, ud.radius, nil, nil,true)
end

function getOreTowerRange(oreTowerID, unitDef)
    if not oreTowerID and not unitDef then
        return defaultOreTowerRange end
    if not unitDef then
        local unitDefID = spGetUnitDefID(oreTowerID)
        unitDef = UnitDefs[unitDefID]
    end
    if not unitDef.buildDistance then
        return defaultOreTowerRange
    end
    return unitDef.buildDistance
end

function getNearestOreTowerID (ud, oreTowers, maxOreTowerScanRange)
    return NearestItemAround(ud.unitID, ud.pos, ud.unitDef, maxOreTowerScanRange, nil,
                function(x) return (oreTowers and oreTowers[x] or nil) end,
                false,
                ud.team) --,
    --(unitID, pos, unitDef, radius, defCheck, idCheck, isFeature, teamID, allyTeamID)
end

function getParentOreTowerID (ud, harvesters)
    return harvesters[ud.unitID] and harvesters[ud.unitID].parentOreTowerID
end


--- returns nil (not a harvester or current amount not initialized) or a given amount from 0 to max
function getUnitHarvestStorage(unitID)
    local oreLoad = spGetUnitRulesParam(unitID, "oreLoad")
    if not isnumber(oreLoad) then
        return 0
    end
    return oreLoad
end

function getLoadPercentage(unitID, unitDef)
    if not unitDef.customParams or not unitDef.customParams.maxorestorage then
        return 0 end
    local maxorestorage = tonumber(unitDef.customParams.maxorestorage)
    return math_clamp(getUnitHarvestStorage(unitID) / maxorestorage, 0,1)
end


----return: parentOreTowerID, nearestOreTowerID2
--function getOreTowerInfo(ud, harvesters, oreTowers, longScanRange)
--    local nearestOreTowerID = NearestItemAround(ud.unitID, ud.pos, ud.unitDef, longScanRange, nil,
--            function(x) return (oreTowers and oreTowers[x] or nil) end)
--
--    local parentOreTowerID = harvesters[ud.unitID].parentOreTowerID or nearestOreTowerID
--
--    return parentOreTowerID, nearestOreTowerID
--end